/*
 Navicat Premium Data Transfer

 Source Server         : mysql80
 Source Server Type    : MySQL
 Source Server Version : 80012
 Source Host           : localhost:3307
 Source Schema         : vueblog

 Target Server Type    : MySQL
 Target Server Version : 80012
 File Encoding         : 65001

 Date: 19/07/2021 13:01:58
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for m_blog
-- ----------------------------
DROP TABLE IF EXISTS `m_blog`;
CREATE TABLE `m_blog`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL,
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `created` timestamp(0) NULL DEFAULT NULL,
  `status` int(2) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id`) USING BTREE,
  CONSTRAINT `m_blog_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `m_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_blog
-- ----------------------------
INSERT INTO `m_blog` VALUES (1, 1, '生活就像海洋，只有意志坚强的人才能到达彼岸', '这里是摘要哈哈哈', '内容？？？', '2020-05-21 22:08:42', 0);
INSERT INTO `m_blog` VALUES (2, 1, 'ElasticSearch入门', 'eblog是一个基于Springboot2.1.2开发的博客学习项目，为了让项目融合更多的知识点，达到学习目的，编写了详细的从0到1开发文档。主要学习包括：自定义Freemarker标签，使用shiro+redis完成了会话共享，redis的zset结构完成本周热议排行榜，t-io+websocket完成即时消息通知和群聊，rabbitmq+elasticsearch完成博客内容搜索引擎等。值得学习的地方很多！', '该笔记来自B站**遇见狂神说**的视频讲解，在学习过程中，完成了以下笔记。在此，对狂神老师说声感谢，并附上视频链接：\n[【狂神说Java】ElasticSearch7.6.x最新完整教程通俗易懂：](https://www.bilibili.com/video/BV17a4y1x7zq)\n\n[https://www.bilibili.com/video/BV17a4y1x7zq](https://www.bilibili.com/video/BV17a4y1x7zq)\n\n\n# ElasticSearch\n\n![](https://img-blog.csdnimg.cn/img_convert/c69c872ce3651e6d7eed0f4f2c50ca63.png)\n\n> Lucece是一套信息检索工具！jar包，不包含搜索引擎系统！\n\n包含的：索引结构！读写索引的工具！排序，搜索规则。。。工具类\n\n**Lucene和ElasticSearch的关系**：\n\nElasticSearch是基于Lucene做了一些封装和增强。\n\n## 一、ElasticSearch概述\n\nElasticSearch，简称ES，es是一个开源的`高扩展`的`分布式全文检索引擎`，它可以近`乎实时的存储，检索数据`；本身扩展性很强，可以扩展到上百台服务器，处理PB级别（大数据时代）的数据。ES也适用Java开发，并适用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的**RestFul API** `（/user get post put delete）`来隐藏Lucene的复杂性，从而让全文搜索变得更简单。\n\n日志数据分析：logstash采集日志，ES进行复杂的数据分析，简称ELK技术，即**ElasticSearch+Logstash+Kibana**\n\n+ ElasticSearch：搜索清洗		\n+ Logstash：过滤     \n+ Kibana：可视化分析\n\n## 二、ElasticSearch和Solr的差别\n\n**ElasticSearch简介**\n\nElasticSearch是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。\n\n它用于`全文搜索`、`结构化搜索`、`分析`以及将这三者混合使用。\n\n通过简单的`RestFul API`来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n\n**Solr简介**\n\nSolr是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器，Solr提供了比Lucene	更为丰富的查询语言，同时实现了可配置、可扩展、并对索引、搜索性能进行了优化。\n\nSolr是基于Lucene开发企业级搜索服务器，实际上就是封装了Lucene。\n\nSolr是一个独立的企业级搜索应用服务器，它对外提供类似于`Web-Service`的API接口\n\n**Lucene简介**\n\nLucene是Apache软件基金会的项目，是一个开源源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎。在Java开发环境中，Lucene是一个成熟的免费开源工具，就本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。\n\n\n\n\n\n## ElasticSearch安装\n\n声明：JDK1.8，最低要求！ElasticSearch客户端，界面工具。\n\nElasticSearch官网：[https://www.elastic.co/cn/](https://www.elastic.co/cn/)\n\nElasticSearch下载地址：[https://www.elastic.co/cn/downloads/elasticsearch](https://www.elastic.co/cn/downloads/elasticsearch)\n\n\nELK三剑客，解压即用！（Web项目，前端环境），依赖于Nodejs和Python ', '2020-05-28 09:36:38', 0);
INSERT INTO `m_blog` VALUES (3, 1, '如何在Docker中查看MySQL的版本', '关注CSDN：【王菜鸟】，可以获取更多资源哦', '首页，进入Docker中的MySQL镜像\n```bash\n# docker exec -it mysql的名称或容器ID bash终端\ndocker exec -it mysql /bin/bash\n```\n\n进入MySQL登录\n```bash\n\nmysql -hlocalhost -uroot -p\n\n```\n\n\n查看版本：\n```bash\nselect version();\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712214029576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzIzNzcz,size_16,color_FFFFFF,t_70)\n', '2020-10-20 05:05:31', 0);
INSERT INTO `m_blog` VALUES (7, 1, '你真的会写单例模式吗?', '单例模式可能是代码最少的模式了，但是少不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对 Java 中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。', '> 作者：吃桔子的攻城狮 来源：http://www.tekbroaden.com/singleton-java.html\n\n\n单例模式可能是代码最少的模式了，但是少不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对 Java 中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。\n\n饿汉法\n===\n\n顾名思义，饿汉法就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。代码如下：\n\n```\npublic class Singleton {  \n    private static Singleton = new Singleton();\n    private Singleton() {}\n    public static getSignleton(){\n        return singleton;\n    }\n}\n\n```\n\n这样做的好处是编写简单，但是无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载，所以就需要下面的懒汉法：\n', '2020-05-22 00:42:44', 0);
INSERT INTO `m_blog` VALUES (9, 1, '真正理解Mysql的四种隔离级别@', '事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\n\n事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。', '### 什么是事务  \n\n> 事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\n> \n> 事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。\n\n**事务的 ACID**\n\n事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。\n\n> 1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做\n> \n> 2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。', '2020-05-22 22:04:46', 0);
INSERT INTO `m_blog` VALUES (15, 1, 'Docker的常用命令', 'Docker的使用，可以大大降低内存的占用问题，同时使用容器化技术，获得高度的灵活性', '该笔记是根据B站Up主——遇见狂神说，讲解的视频记录完成\n\n遇见狂神说：https://space.bilibili.com/95256449\n\n\n\n\n\nDocker常用命令\n\nDocker官网：https://www.docker.com/\n\n\n\n## 第一部分\n\n### 一、帮助命令\n\n```shell\ndocker version 			# 显示docker的版本信息\ndocker info 			# 显示docker的系统信息，包括镜像和容器的数量\ndocker 命令 --help   	   # 帮助命令\n```\n\n### 二、镜像命令\n\n安装镜像的搜索网址：\n\nhttps://hub.docker.com/\n\n#### 2.1、下载镜像\n\n```shell\ndocker images			 # 查看所有本地主机上的镜像\n\ndocker search mysql      # 搜索镜像\n\ndocker pull --help 		 # 下载镜像\ndocker pull mysql:5.7    # 指定MySQL的版本\n\n```\n\n#### 2.2、删除镜像\n\n```shell\ndocker rmi -f id		 # 删除指定的镜像，remove image，加上镜像ID\ndocker rmi -f id id id 	 # 删除多个镜像\ndocker rmi -f $(docker image -aq)   # 批量删除全部的image(-f表示全部删除，即force,-ap查询命令)\n```\n\n### 三、容器命令\n\n下载CentOS镜像\n\n```shell\ndocker pull centos\n```\n\n新建容器并启动\n\n```shell\ndocker run --help\ndocker run [可选参数] image\n# 参数说明\n--name=\"Name\"		容器名字  Tomcat1 Tomcat2 用来区分容器\n-d 					后台方式运行\n-it					使用交互方式运行，进入容器查看内容\n-p					指定容器的端口，-p  8080:8080\n	-p ip:主机端口：容器端口\n	-p 主机端口：容器端口（常用）\n	-p 容器端口\n-P					随机指定端口\n```\n\n\n\n启动并进入容器\n\n```shell\ndocker run -it centos /bin/bash\n```\n\n从容器中退回主机\n\n```shell\nexit			# 直接停止容器并退出\nCtrl + P + Q	# 容器不停止退出\nls\n```\n\n列出所有的运行容器\n\n```shell\ndocker ps\n-a 			# 列出当前正在运行的容器，带出历史运行过的容器\n-n=? 		# 显示最近创建的容器\n-q			# 只显示容器的编号\ndocker ps -a\n```\n\n删除容器\n\n```shell\ndocker rm 容器id						# 删除指定的容器，不能删除正在运行的容器，如果要强制删除，加采纳数rm -f\ndocker rm -f $(docker ps -aq)	 	 # 删除所有的容器	\ndocker ps -a -q | xargs docker rm 	 # 删除所有的容器（管道命令）\n```\n\n启动和停止容器的操作\n\n```shell\ndocker start 容器ID		# 启动容器\ndocker restart 容器ID		# 重启容器\ndocker stop 容器ID		# 停止正在运行的容器\ndocker kill 容器ID		# 强制停止当前容器\n```\n\n### 四、常见其他命令\n\n后台启动容器\n\n```shell\ndocker run -d 镜像名\ndocker run -d centos\n# 问题：docker ps，发现centos停止了\n\n# 常见的坑：docker 容器使用后台运行，就必须要有一个前台进程,docker发现没有应用，就会自动停止\n\n# Nginx容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序运行了\n\n```\n\n查看日志\n\n```shell\ndocker logs --help\ndocker logs -f -t --tail 容器ID			# 容器如果没有日志\n# 自己编写shell脚本\n\"while true;do echo OriginalCoder;sleep 1;done\"\ndocker run -d centos /bin/sh -c \"while true;do echo OriginalCoder;sleep 1;done\"\ndocker ps # 查看容器ID\n\n显示日志\n-tf   				# 显示日志（-t:时间戳，-f:持续显示日志）\n--tail number 		# 要显示的日志条数\ndocker logs -ft --tails 10 容器ID（10代表打印的条数）\n```\n\n查看容器中进程信息ps\n\n```shell\ndocker ps 			# 查看容器ID\ndocker top 容器ID\n```\n\n查看镜像的元数据\n\n```shell\ndocker inspect --help\ndocker ps -a\ndocker inspect 容器ID\n```\n\n进入当前正在运行的容器\n\n```shell\n通常情况下，容器都是后台运行的，需要进入容器中，修改一些配置\n\n# 方式一\ndocker exec -it 容器ID /bin/bash\nls\nps -ef\n\n# 方式二\ndocker attach 容器ID\n\n区别\n# docker exec 		进入容器后开启一个新的终端，可以在里面操作\n# docker attach 	进入容器正在执行的终端，不会启动新的进程\n```\n\n从容器内拷贝文件到主机上\n\n```shell\ndocker cp 容器ID: 容器内路径 目的主机路径\ndocker ps\ndocker images\ndocker run -it centos /bin/bash\ndocker ps \n\n\ndocker attach 容器ID\ncd /home\nls\n容器内新建一个文件\n# touch test.java\nexit\ndocker ps -a\n# 将这个文件拷贝出来到主机上\ndocker cp 容器ID:/home/test.java /home\nls\n```\n\n### 五、 总结\n\n\n\n![](https://cdn.jsdelivr.net/gh/OriginalCoder0/gallery@master/images/1625897215965-docker.png)\n\n> attach    Attach to a running container  #当前shell下attach连接指定运行镜像\n> build     Build an image from a Dockerfile  #通过Dockerfile定制镜像\n> commit    Create a new image from a containers changes  #提交当前容器为新的镜像\n> cp    Copy files/folders from a container to a HOSTDIR or to STDOUT  #从容器中拷贝指定文件或者目录到宿主机中\n> create    Create a new container  #创建一个新的容器，同run 但不启动容器\n> diff    Inspect changes on a containers filesystem  #查看docker容器变化\n> events    Get real time events from the server#从docker服务获取容器实时事件\n> exec    Run a command in a running container#在已存在的容器上运行命令\n> export    Export a containers filesystem as a tar archive  #导出容器的内容流作为一个tar归档文件(对应import)\n> history    Show the history of an image  #展示一个镜像形成历史\n>\n> \n>\n> images    List images  #列出系统当前镜像\n> import    Import the contents from a tarball to create a filesystem image  #从tar包中的内容创建一个新的文件系统映像(对应export)\n> info    Display system-wide information  #显示系统相关信息\n> inspect    Return low-level information on a container or image  #查看容器详细信息\n> kill    Kill a running container  #kill指定docker容器\n> load    Load an image from a tar archive or STDIN  #从一个tar包中加载一个镜像(对应save)\n> login    Register or log in to a Docker registry#注册或者登陆一个docker源服务器\n> logout    Log out from a Docker registry  #从当前Docker registry退出\n> logs    Fetch the logs of a container  #输出当前容器日志信息\n> pause    Pause all processes within a container#暂停容器\n> port    List port mappings or a specific mapping for the CONTAINER  #查看映射端口对应的容器内部源端口\n> ps    List containers  #列出容器列表\n> pull    Pull an image or a repository from a registry  #从docker镜像源服务器拉取指定镜像或者库镜像\n> push    Push an image or a repository to a registry  #推送指定镜像或者库镜像至docker源服务器\n>\n> \n>\n> rename    Rename a container  #重命名容器\n> restart    Restart a running container  #重启运行的容器\n> rm    Remove one or more containers  #移除一个或者多个容器\n> rmi    Remove one or more images  #移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除)\n> run    Run a command in a new container  #创建一个新的容器并运行一个命令\n> save    Save an image(s) to a tar archive#保存一个镜像为一个tar包(对应load)\n> search    Search the Docker Hub for images  #在docker\n> hub中搜索镜像\n> start    Start one or more stopped containers#启动容器\n> stats    Display a live stream of container(s) resource usage statistics  #统计容器使用资源\n> stop    Stop a running container  #停止容器\n> tag         Tag an image into a repository  #给源中镜像打标签\n> top       Display the running processes of a container #查看容器中运行的进程信息\n> unpause    Unpause all processes within a container  #取消暂停容器\n> version    Show the Docker version information#查看容器版本号\n> wait         Block until a container stops, then print its exit code  #截取容器停止时的退出状态值\n\n### 六、练习\n\n> Docker安装Nginx\n\n\n\nPS：建议在DockerHub上搜索镜像，这样你可以找到自己想要的镜像版本，地址：https://hub.docker.com/\n\n```shell\ndocker search nginx\ndocker push nginx\ndocker images\n\n# -d 后台运行\n# --name 给容器命名\n# -p 宿主机端口:容器内端口\ndocker run -d --name Nginx01 -p 3344:80 nginx\n# 测试\ncurl localhost:3344\n\n\n# 进入容器\ndocker exec -it nginx01 /bin/bash\nwhereis nginx \ncd /etc/nginx\nls\n\n```\n\n上面代码可能涉及到的问题：\n\n```shell\n# 永久关闭防火墙\nsystemctl disable firewalld.service\n```\n\n\n\n\n\n端口暴露的概念\n\n![](https://cdn.jsdelivr.net/gh/OriginalCoder0/gallery@master/images/1625898282295-docker1.png)\n\n思考问题：我们每次修改Nginx的配置文件，都需要进入容器内部，十分麻烦。可以在容器外提供一个映射的路径，达到在容器修改文件名，容器内部就可以自动修稿同步？`-v，数据卷`\n\n`-v  /usr/share/nginx:/user/nginx`\n\n\n\n> Docker安装Tomcat\n\n```shell\n# 官方的使用\ndocker run -it --rm tomcat:9.0\n\n# 之前启动的都是后台，停止了容器之后，容器还是可以查到，docker run -it --rm ，一般用来测试，用完即删\n```\n\n\n\n```shell\n# 建议使用以下\ndocker pull tomcat:9.0			# 下载Tomcat\ndocker images\n# 启动运行\ndocker run -d -p 3355:8080 --name tomcat tomcat\n\n\n说明：通过以上方式就能测试访问成功，但是通过外网访问时，出现404\n# 进入容器\ndocker exec -it tomcat01 /bin/bash\n\n# 发现问题：1.Linux命令少了；2.没有webapps。		原因：阿里云镜像默认是最小的镜像，所以不必要的都被剔除\n```\n\n\n\n> Docker安装Redis\n\n```shell\ndocker pull redis\ndocker image inspect redis:latest\n```\n\n### 七、Commit镜像\n\n```shell\ndocker commit 提交容器成为一个新的副本\n\ndocker commti -m \"提交的描述信息\"  -a=\"作者\" 容器ID 目标镜像名:[TAG]\n\ndocker images\ndocker run -it -p 8080:8080 镜像名\ndocker ps\ndocker exec -it 容器ID /bin/bash\n\ndocker commit -a=\"作者\" -m=\"描述信息\" 容器ID 新容器名称：表情\n\n```\n\n### 八、容器数据卷\n\n什么是容器数据卷？\n\n> 将应用和环境，打包成一个镜像。数据如果都在容器中，那么容器删除，数据就会丢失。\n\n`需求:数据可以持久化`\n\nMySQL:容器删了，就相当于删库跑路！`需求`:MySQL数据可以存储在本地！\n\n容器之间有一个数据共享的技术！Docker容器中产生的数据，同步到本地！这就是卷技术。\n\n目录的挂载，	将我们容器内的目录，挂载到Linux上。\n\n\n\n![](https://cdn.jsdelivr.net/gh/OriginalCoder0/gallery@master/images/1625975320734-docker-juan.png)\n\n```总结```:容器的持久化和同步操作！容器间也是可以数据共享的！\n\n\n\n使用数据卷\n\n> 方式一：直接使用命令来挂载 -V\n\n```shell\ndocker run -it -V 主机目录 容器内目录\n\n# 测试\ndocker run -it -v /home/ceshi:/home centos /bin/bash\n\n# 回到容器之外的控制台，使用以下命令，查看是否挂载成功\ndocker inspect 容器ID	\n```\n\n![](https://cdn.jsdelivr.net/gh/OriginalCoder0/gallery@master/images/1625975793182-mount.png)\n\n测试文件的同步\n\n\n\n![](https://cdn.jsdelivr.net/gh/OriginalCoder0/gallery@master/images/1625980517764-test.png)\n\n再次测试\n\n1、停止容器\n\n2、宿主机上修改文件\n\n3、启动容器\n\n4、容器内的数据依旧是同步的\n\n\n\n![](https://cdn.jsdelivr.net/gh/OriginalCoder0/gallery@master/images/1625980711401-test2.png)\n\n好处：我们以后修改只需要在本地修改即可，容器内自动同步！\n\n\n\n\n\n\n\n## 第二部分\n\n\n\n### 一、实战：安装MySQL\n\n思考：MySQL的数据持久化问题\n\n```shell\n# 获取镜像\ndocker search mysql\ndocker pull mysql:5.7\n\n# 运行容器,需要做数据挂载\n# 安装启动mysql，需要配置密码（注意点）\n# 官方测试：docker run -it --network some-network --rm mysql mysql -hsome-mysql -uexample-user -p\n# 运行\n-d 后台运行\n-p 端口映射\n-v 卷挂载\n-e 环境配置\n--name 容器名字	\ndocker run -d -p 3310:3306 -v /home/mysql.conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7\n# 启动成功之后，可以在Windows本地机测试\n```\n\n假设我们将容器删除\n\n```shell\ndocker rm -f mysql01\ndocker ps\ndocker ps -a\n\n```\n\n回到宿主机查看，发现数据都还在！	我们挂载到本地的数据卷没有丢失，这就实现了容器数据持久化功能。\n\n\n\n### 二、具名挂载和匿名挂载\n\n```shell\n# 匿名挂载\n-v 容器内路径\ndocker run d -P --name nginx01 -v /etc/nginx nginx\n\n# 查看所有数据卷的情况\ndocker volume ls\n\n \n```\n\n\n\n### 三、DockerFile\n\nDockerFile就是用来构建docker镜像的构建文件！命令脚本\n\n```shell\nmkdir docker-test-volume\nls\npwd\ncd docker-test-volume/\npwd\n\n# 通过下面这个脚本，可以生成镜像，镜像是一层一层的，脚本是一层层的命令，每一个命令都是一层\nvim dockerfile1\n	FROM centos\n	VOLUME [\'volume01\',\'volume02\']\n	CMD echo \"----end----\"\n	CMD /bin/bash\n	ESC\n	:wq\n\n# 查看dockerfile1\ncat dockerfile1\n# \ndocker build -f /home/docker-test--volume/docekrfile1 -t rich/centos:1.0 .\n```\n\n启动自己写的容器\n\n![](https://cdn.jsdelivr.net/gh/OriginalCoder0/gallery@master/images/1625986496053-data.png)\n\n这个卷和外部一定有一个同步的目录\n\n### 四、数据卷容器\n\n![](https://cdn.jsdelivr.net/gh/OriginalCoder0/gallery@master/images/1625986882879-datas.png)\n\n### 五、SpringBoot+Vue博客打包Docker镜像\n\n1、构建SpringBoot项目\n\n2、打包应用\n\n3、编写DockerFile\n\n4、构建镜像\n\n5、发布运行\n\n以后在使用Docker的时候，给别人一个Docker的镜像就可以\n\n\n\n\n\n#### Docker Compose\n\n#### Docker Swarm\n\n#### CI/CD之Jenkins\n\n', '2021-07-18 18:43:09', 0);
INSERT INTO `m_blog` VALUES (16, 1, 'SpringBoot+Vue项目中的跨域问题的处理', 'SpringBoot+Vue项目中的跨域问题的处理', '在使用SpringBoot + Vue的项目中，出现了以下 的错误信息：\n> When allowCredentials is true, allowedOrigins cannot contain the special value \"*\"since that cannot be set on the \"Access-Control-Allow-Origin\" response header. To allow credentials to a set of origins, list them explicitly or consider using \"allowedOriginPatterns\" instead.\n\n\n解决跨域问题的配置通常如下：\n```java\n\n@Configuration\npublic class CorsConfig  implements WebMvcConfigurer {\n\n    /**\n     * 设置允许跨域访问\n     *\n     * @param registry 配置注册信息\n     */\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry\n                //允许访问的接口地址\n                .addMapping(\"/**\")\n                //允许发起跨域访问的域名\n                .allowedOrigins(\"*\")\n                //允许跨域访问的方法\n                .allowedMethods(\"GET\",\"HEAD\",\"POST\",\"PUT\",\"DELETE\",\"OPTIONS\")\n                //是否带上cookie信息\n                .allowCredentials(true)\n                .maxAge(3600)\n                .allowedHeaders(\"*\");\n    }\n}\n```\n\n\n大体意思就是：当allowCredentials设置为true的时候，allowedOrigins不能包含特殊字符*。因为在请求头中的Access-Control-Allow-Origin是不能设置*的。如果要用的话，可以试试将allowedOrigins改为allowedOriginPatterns。\n\n### 措施一\n因此，有两种办法解决以上的报错信息。第一种在CORS（）配置中添加下面的代码：\n```java\nallowedOriginPatterns(\"*\")\n```\n\n修改后的跨域配置如下：\n```java\n\n@Configuration\npublic class CorsConfig  implements WebMvcConfigurer {\n\n    /**\n     * 设置允许跨域访问\n     *\n     * @param registry 配置注册信息\n     */\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry\n                //允许访问的接口地址\n                .addMapping(\"/**\")\n                //允许发起跨域访问的域名\n                .allowedOriginPatterns(\"*\")\n                //允许跨域访问的方法\n                .allowedMethods(\"GET\",\"HEAD\",\"POST\",\"PUT\",\"DELETE\",\"OPTIONS\")\n                //是否带上cookie信息\n                .allowCredentials(true)\n                .maxAge(3600)\n                .allowedHeaders(\"*\");\n    }\n}\n```\n\n\n### 措施二\n修改SpringBoot的版本号，在SpringBoot2.4.2中必须要带上跨域通配符。\n两种方式都亲测有效，但是笔者采用的是第二种方式。\n那么如何修改SpringBoot的版本号呢？\n在你的SpringBoot配置依赖的文件`pom.xml`中，找到以下配置\n```xml\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.0.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n</parent>\n```\n或者在pom.xml的配置依赖中，直接修改SpringBoot的版本号！', '2021-07-18 20:02:15', 0);

-- ----------------------------
-- Table structure for m_user
-- ----------------------------
DROP TABLE IF EXISTS `m_user`;
CREATE TABLE `m_user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `status` int(2) NULL DEFAULT NULL,
  `created` datetime(0) NULL DEFAULT NULL,
  `last_login` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_user
-- ----------------------------
INSERT INTO `m_user` VALUES (1, 'admin', 'https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg', 'admin@qq.com', '96e79218965eb72c92a549dd5a330112', 0, '2020-04-20 10:44:01', NULL);
INSERT INTO `m_user` VALUES (2, 'root', NULL, 'root@qq.com', '123456', 0, NULL, NULL);

SET FOREIGN_KEY_CHECKS = 1;
